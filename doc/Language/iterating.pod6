=begin pod :tag<perl6>

=TITLE Iterating

=SUBTITLE Functionalities available for visiting all items in a complex data structure

=head1 The C<Iterator> and C<Iterable> roles

Perl 6 is a functional language, but functions need something to hold on to when
working on complex data structures. In particular, they need an uniform
interface that can be applied to all of them. This interface is provided by the
L<Iterator> and L<Iterable> roles.

The C<Iterable> role is relatively simple. It provides a stub for the C<iterator> method, which is the one actually used by statements such as C<for>. C<for> will call C<.iterator> on the variable it precedes, and then run a block once for every item. Other methods, such as array assignment, will make the C<Iterable> class behave in the same way.

=begin code
class DNA does Iterable {
    has $.chain;
    method new ($chain where {
                       $chain ~~ /^^ <[ACGT]>+ $$ / and
                       $chain.chars %% 3 } ) {
        self.bless( :$chain );
    }

    method iterator(DNA:D:){ $.chain.comb.rotor(3).iterator }
};

my @longer-chain =  DNA.new('ACGTACGTT');
say @longer-chain.perl;
# OUTPUT: «[("A", "C", "G"), ("T", "A", "C"), ("G", "T", "T")]»

say  @longer-chain».join("").join("|"); #OUTPUT: «ACG|TAC|GTT»
=end code

In this example, which is an extension of the
L<example in C<Iterable> that shows how C<for> calls C<.iterator>|/type/Iterable>,
this method is called simply when the created object is assigned to a L<Positional> variable, C<@longer-chain>; this variable is an L<Array> and we operate on that in the last example.

=head1 How to iterate: contextualizing and topic variables

TBD

=head1 C<Classic> loops and why we do not like them

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
