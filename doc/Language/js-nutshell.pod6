=begin pod :tag<convert>

=TITLE Perl 6 from Node.js - Nutshell

=SUBTITLE Learning Perl 6 from Node.js, in a nutshell.

This page attempts to provide a way for users experienced in Node.js to learn
Perl 6. Features shared between the two languages will be explained here, as
well as major differences in syntax and features.

This is not a tutorial for learning Perl 6; this is a reference for users who
are already at an intermediate to advanced skill level with Node.js.

=head1 Basic Syntax

=head2 "Hello, world!"

Let's start with the typical first program when learning new languages. In
Node.js, a hello world program would be written like this:

=begin code :lang<javascript>
console.log('Hello, world!');
=end code

Here are a couple ways to write this in the same way in Perl 6:

=begin code
say('Hello, world!');
say 'Hello, world!';
=end code

Parentheses are optional for function calls in Perl 6. While semicolons are,
for the most part, optional in Node.js, they are mandatory for expressions in
Perl 6.

Now that we've greeted the world, let's greet our good friend, Joe. We'll
start with Node.js again:

=begin code :lang<javascript>
let name = 'Joe';
console.log('What\'s up,' + name + '?');
console.log(`What's up, {name}?`);
console.log("What's up, ", name, "?");
=end code

Since he didn't hear us, let's greet him again, this time in Perl 6:

=begin code
my $name = 'Joe';
say 'What\'s up, ' ~ $name ~ '?';
say "What's up, $name?";
say "What's up, ", $name, "?";
=end code

Here, there are only a couple differences: most variables in Perl 6 have what
are called sigils, which are what the C<$> in front of its name is, and string
concatenation uses the C<~> operator instead of C<+>. What the two languages
share in common here is support for string interpolation.

Now that the basic examples are out of the way, let's explain the similarities
between the two languages in greater detail.

=head2 Variables

Variables in Node.js can be defined like this;

=begin code :lang<javascript>
var foo = 1;    // Lexically scoped with functions and modules
let foo = 1;    // Lexically scoped with blocks
const foo = 1;  // Lexically scoped with blocks; constant

global.foo = 1; // Dynamically scoped; global
foo = 1;        // Ditto, but implicit; forbidden in strict mode
=end code

In Perl 6 there is no equivalent to C<var>. An important note to make is that
there is no variable hoisting in Perl 6; variables are defined and assigned
at the line they're on, not defined at the top of its scope and later assigned
at that line.

This is how the equivalent types of variables are defined in Perl 6:

=begin code
my $foo = 1;      # Lexically scoped with blocks
our $foo = 1;     # Lexically scoped with blocks and modules
constant foo = 1; # Lexically scoped with blocks and modules; constant

my $*foo = 1;       # Dynamically scoped with blocks
OUR::<$foo> = 1;    # Dynamically scoped with blocks and modules
GLOBAL::<$foo> = 1; # Dynamically scoped; global
=end code

Use C<my> where you'd use C<let>, C<our> for variables you'd define in the
outermost scope needed, and C<constant> where you'd uses C<const>.

Dynamically scoped variables are not referred to in the same way as lexically
scoped ones like they are in Node.js. User-defined ones use either a C<$*>,
C<@*>, C<%*>, or C<&*> twigil. Refer to the documentation on
L<variables|/language/variables> for more information on sigils, twigils, and
variable containers.

Variables in Node.js can override others from outer scopes with the same name
(though linters will usually complain about it depending on how they're
configured):

=begin code :lang<javascript>
let foo = 1;
function logDupe() {
    let foo = 2;
    console.log(foo);
}

logDupe(2);       // 2
console.log(foo); // 1
=end code

Perl 6 also allows this:

=begin code
my $foo = 1;
sub log-dupe {
    my $foo = 2;
    say $foo;
}

log-dupe; # 2
say $foo; # 1
=end code

=head2 Operators

=head3 Assignment

The C<=> operator works the same across both languages.

The C<:=> operator in Perl 6 binds a value to a variable. Binding a variable
to another variable gives them the same value and container, meaning mutating
attributes of one will mutate the other's as well. Bound variables cannot be
reassigned with C<=> or mutated with C<++>, C<-->, etc. but they can be bound
to another value again:

=begin code
my %map;            # This is a hash, roughly equivalent to a JS object or map
my %unbound = %map;
my %bound := %map;
%map<foo> = 'bar';
say %unbound;       # {}
say %bound;         # {foo => bar}

%bound := %unbound;
say %bound;         # {}
=end code

=comment TODO: operators for equality, bitwise, etc.

=head2 Conditionals

=comment TODO

# TBD

=head2 Functions

=comment TODO

# TBD

=head2 Types

=comment TODO

# TBD

=head1 Object-Oriented Programming

=comment TODO

# TBD

=head1 The Networking API

=comment TODO

# TBD

=head1 The File System API

=comment TODO

# TBD

=head1 Modules and Packages

=comment TODO

# TBD

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
