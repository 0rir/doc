=begin pod :tag<perl6>

=TITLE Doing math with Perl 6

=SUBTITLE Different mathematical paradigms and how they are implemented in this language.

=head1 Sets.

Perl 6 includes the L<Set> data type, as well as support for L<most set operations|/language/setbagmix#Set/Bag_Operators>. L<Union and intersection|https://en.wikipedia.org/wiki/Algebra_of_sets> are not only native operations, they use their I<natural> symbols, ∩ and ∪. For instace, this code would check the fundamental laws of the arithmetic of sets for a limited number of sets:

=begin code
my @arbitrary-numbers = ^100;
my \U = @arbitrary-numbers.Set;
my \Ø = ().Set;

my @sets;

@sets.push: Set.new( @arbitrary-numbers.pick( @arbitrary-numbers.elems.rand)) for @arbitrary-numbers;

my (@union, @intersection);

for @sets -> $set {
    @union.push: $set ∩ $set === $set;
    @intersection.push: $set ∪ $set === $set;
}

say "Idempotent union is ", so @union.all;
# OUTPUT: «Idempotent union is True»
say "Idempotent intersection is ", so @intersection.all;
# OUTPUT: «Idempotent intersection is True»
my (@universe, @empty-set, @id-universe, @id-empty);

for @sets -> \A {
    @universe.push: A ∪ U === U;
    @id-universe.push: A ∩ U === A;
    @empty-set.push: A ∩ Ø === Ø;
    @id-empty.push: A ∪ Ø === A;
}

say "Universe dominates ", so @universe.all;    # OUTPUT: «Universe dominates True»
say "Empty set dominates ", so @empty-set.all;  # OUTPUT: «Empty set dominates True»

say "Identity with U ", so @id-universe.all;    # OUTPUT: «Identity with U True»
say "Identity with Ø ", so @id-empty.all;       # OUTPUT: «Identity with Ø True»
=end code

In this code, not only we check if the equalities in the algebra of sets hold, we also use, via L<sigilless variables|/language/variables#index-entry-\_(sigilless_variables)> and the Unicode form of the set operators, expressions that are as close as possible to the original form; C<A ∪ U === U>, for example, except for the use of the L<value identity operator <===>|/routine/===> is very close to the actual mathematical expression in the L<Wikipedia entry|https://en.wikipedia.org/wiki/Algebra_of_sets>.

We can even test de Morgan's law, as in the code below:

=begin code
my @alphabet = 'a'..'z';
my \U = @alphabet.Set;
sub postfix:<⁻>(Set $a) { U ⊖ $a }
my @sets;
@sets.push: Set.new( @alphabet.pick( @alphabet.elems.rand)) for @alphabet;
my ($de-Morgan1,$de-Morgan2) = (True,True);
for @sets X @sets -> (\A, \B){
    $de-Morgan1 &&= (A ∪ B)⁻  === A⁻ ∩ B⁻;
    $de-Morgan2 &&= (A ∩ B)⁻  === A⁻ ∪ B⁻;
}
say "1st De Morgan is ", $de-Morgan1;
say "2nd De Morgan is ", $de-Morgan2;
=end code

We declare C<⁻> as the I<complement> operation, which computes the symmetrical difference ⊖ between the Universal set C<U> and our set. Once that is declared, it is relatively easy to express operations such as the complementary of the union of A and B C<(A ∪ B)⁻>, with a notation that is very close to the original mathematical notation.

=head1 Arithmetic.

TBD

=head1 Sequences

TBD

=head1 Mathematical constants

TBD


=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
