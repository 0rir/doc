=begin pod :tag<perl6>

=TITLE Doing math with Perl 6

=SUBTITLE Different mathematical paradigms and how they are implemented in this language.

=head1 Sets.

Perl 6 includes the L<Set> data type, as well as support for L<most set operations|/language/setbagmix#Set/Bag_Operators>. L<Union and intersection|https://en.wikipedia.org/wiki/Algebra_of_sets> are not only native operations, they use their I<natural> symbols, ∩ and ∪. For instace, this code would check the fundamental laws of the arithmetic of sets for a limited number of sets:

=begin code
my @arbitrary-numbers = ^100;
my \U = @arbitrary-numbers.Set;
my \Ø = ().Set;

my @sets;

@sets.push: Set.new( @arbitrary-numbers.pick( @arbitrary-numbers.elems.rand)) for @arbitrary-numbers;

my (@union, @intersection);

for @sets -> $set {
    @union.push: $set ∩ $set === $set;
    @intersection.push: $set ∪ $set === $set;
}

say "Idempotent union is ", so @union.all;
# OUTPUT: «Idempotent union is True»
say "Idempotent intersection is ", so @intersection.all;
# OUTPUT: «Idempotent intersection is True»
my (@universe, @empty-set, @id-universe, @id-empty);

for @sets -> \A {
    @universe.push: A ∪ U === U;
    @id-universe.push: A ∩ U === A;
    @empty-set.push: A ∩ Ø === Ø;
    @id-empty.push: A ∪ Ø === A;
}

say "Universe dominates ", so @universe.all;    # OUTPUT: «Universe dominates True»
say "Empty set dominates ", so @empty-set.all;  # OUTPUT: «Empty set dominates True»

say "Identity with U ", so @id-universe.all;    # OUTPUT: «Identity with U True»
say "Identity with Ø ", so @id-empty.all;       # OUTPUT: «Identity with Ø True»
=end code

In this code, not only we check if the equalities in the algebra of sets hold, we also use, via L<sigilless variables|/language/variables#index-entry-\_(sigilless_variables)> and the Unicode form of the set operators, expressions that are as close as possible to the original form; C<A ∪ U === U>, for example, except for the use of the L<value identity operator <===>|/routine/===> is very close to the actual mathematical expression in the L<Wikipedia entry|https://en.wikipedia.org/wiki/Algebra_of_sets>.

We can even test de Morgan's law, as in the code below:

=begin code
my @alphabet = 'a'..'z';
my \U = @alphabet.Set;
sub postfix:<⁻>(Set $a) { U ⊖ $a }
my @sets;
@sets.push: Set.new( @alphabet.pick( @alphabet.elems.rand)) for @alphabet;
my ($de-Morgan1,$de-Morgan2) = (True,True);
for @sets X @sets -> (\A, \B){
    $de-Morgan1 &&= (A ∪ B)⁻  === A⁻ ∩ B⁻;
    $de-Morgan2 &&= (A ∩ B)⁻  === A⁻ ∪ B⁻;
}
say "1st De Morgan is ", $de-Morgan1;
say "2nd De Morgan is ", $de-Morgan2;
=end code

We declare C<⁻> as the I<complement> operation, which computes the symmetrical difference ⊖ between the Universal set C<U> and our set. Once that is declared, it is relatively easy to express operations such as the complementary of the union of A and B C<(A ∪ B)⁻>, with a notation that is very close to the original mathematical notation.

=head1 Arithmetic.

Perl 6 can do arithmetic using different data types. L<Num>, L<Rat> and L<Complex> can all operate as a L<field under the operations addition, subtraction, multiplication and division|https://en.wikipedia.org/wiki/Field_(mathematics)>. The equivalent mathematical fields are:

=begin table
Perl 6 class       Field
=============    ==============================================
C<Rat>           ℚ
C<Num>           ℝ
C<Complex>       ℂ
=end table

The C<Int>s, although technically corresponding to Z, is not really a mathematical field since they are not closed under the four arithmetical operations, and integers do not satisfy the L<identity axiom|https://math.stackexchange.com/questions/2192317/set-of-integers-not-a-field/2192330>. However, if the integer division C<div> is used, their operations will always yield other integers; if C</> is used, however, in general the result will be a L<Rat>.

Also strictly speaking, the Rational class that behave like a mathematical field is L<FatRat>. For efficiency reasons, operating with C<Rat>s will fall back ton C<Num> when the numbers are big enough or when there is a big difference between numerator and denominator. C<FatRat>, as well as its equivalent for integers L<BigInt>, can work with arbitrary precision.

Some modules in the ecosystem can work with additional data types mathematically:

=item L<Math::Matrix|https://github.com/pierre-vigier/Perl6-Math-Matrix> operates on the L<matrix field|https://en.wikipedia.org/wiki/Matrix_field>.
=item L<Math::Quaternion|https://github.com/Util/Perl6-Math-Quaternion> operates on the L<quaternion field|https://en.wikipedia.org/wiki/Quaternion>, which are a generalization of complex numbers.
=item

=head1 Sequences

TBD

=head1 Mathematical constants

TBD


=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
