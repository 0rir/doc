=begin pod :tag<perl6>

=TITLE Numerics

=SUBTITLE Numeric types available in Perl 6

=head1 C<Int>

The C<Int> type offers arbitrary-size integer numbers. They can get as big
as your computer memory allows, although some implementations choose to
throw a numeric overflow error when asked to produce integers of truly
staggering size:

=begin code :skip-test<compile-time constant folding will throw example error>
say 10**600**600
# OUTPUT: «Numeric overflow␤»
=end code

Unlike some languages, division performed using
L<C«/» operator|/routine/$SOLIDUS> when both operands are of L<Int>
type, would produce a fractional number, without any rounding performed.

=begin code
say 4/5; # OUTPUT: «0.8␤»
=end code

The type produced by this division is either a L<Rat> or a L<Num> type. The
L<Rat> is produced if, after reduction, the fraction's denominator is smaller
than 64 bits, otherwise a L<Num> type is produced.

The L<div> and L<narrow> routines can be helpful if you wish to end
up with an L<Int> result, whenever possible. The L<div> operator performs
integer division, discarding the remainder, while L<narrow> fits the number
into the narrowest type it'll fit:

=begin code
say 5 div 2; # OUTPUT: «2␤»

# Result `2` is narrow enough to be an Int:
say (4/2).narrow; # OUTPUT: «2␤»
say (4/2).narrow.^name; # OUTPUT: «Int␤»

# But 2.5 has fractional part, so it ends up being a Rat type:
say (5/2).narrow.^name; # OUTPUT: «Rat␤»
say (5/2).narrow;       # OUTPUT: «2.5␤»

# Denominator is too big for a Rat, so a Num is produced:
say 1 / 10⁹⁹; # OUTPUT: «1e-99␤»
=end code

Perl 6 has L<FatRat> type that offers arbitrary precision fractions. How come
a limited-precision L<Num> is produced instead of a L<FatRat> type in the
last example above? The reason is: performance. Most operations are fine
with a little bit of precision lost and so do not require the use of a more
expensive L<FatRat> type. You'll need to instantiate one yourself if you wish
to have the extra precision.

=head1 C<Num>

The L<Num> type offers
L<double-precision floating-point|https://en.wikipedia.org/wiki/Double-precision_floating-point_format> decimal numbers, sometimes called "doubles" in other languages.

A L<Num> literal is written with the exponent separated using letter C<e>. Keep
in mind that letter C<e> B<is required> even if the exponent is zero, as
otherwise you'll get a L<Rat> or L<MidRat> rational literal instead:

=begin code
say 42e0.^name; # OUTPUT: «Num␤»
say 42.0.^name; # OUTPUT: «Rat␤»
=end code

Case-sensitive words L<Inf> and L<NaN> represent special values infinity and
not-a-number respectively. The U+221E INFINITY (C<∞>) character can be used
instead of L<Inf>:

Perl 6 follows the
L<IEEE 754-2008 Standard for Floating-Point Arithmetic|https://en.wikipedia.org/wiki/IEEE_754> as much as possible, with
more conformance planned to be implemented in later language versions. The
language guarantees the closest representable number is chosen for any given
L<Num> literal and does offer support for negative zero and
L<denormals|https://en.wikipedia.org/wiki/Denormal_number> (also known as
"subnormals").

Keep in mind that output routines like L<say> or L<put> do not try very hard to
distinguish between how L<Numeric> types are output and may choose to display
a L<Num> as an L<Int> or a L<Rat> number. For a more definitive string to
output, use the L<perl> method:

=begin code
say  1e0;      # OUTPUT: «1␤»
say .5e0;      # OUTPUT: «0.5␤»
say  1e0.perl; # OUTPUT: «1e0␤»
say .5e0.perl; # OUTPUT: «0.5e0␤»
=end code

=head1 C<Complex>

The L<Complex> type numerics of the
L<complex plane|https://en.wikipedia.org/wiki/Complex_plane>. The L<Complex>
objects consist of two L<Num> objects representing the
L<real|/routine/re> and L<imaginary|/routine/im> portions of the complex number.

To create a L<Complex>, you can use the L«postfix C<i> operator|/routine/i»
on any other non-complex number, optionally setting the real part with
addition. To use the C<i> operator on C<NaN> or C<Inf> literals, separate it
from them with a backslash.

=begin code
say 42i;      # OUTPUT: «0+42i␤»
say 73+42i;   # OUTPUT: «73+42i␤»
say 73+Inf\i; # OUTPUT: «73+Inf\i␤»
=end code

Keep in mind the above syntax is just an addition expression and precedence
rules apply. It also cannot be used in places that forbit expressions, such
as literals in routine parameters.

=begin code
# Precedence of `*` is higher than that of `+`
say 2 * 73+10i; # OUTPUT: «146+10i␤»
=end code

To avoid these issues, you can choose to use the L<Complex> literal syntax
instead, which involves surrounding the real and imaginary parts with angle
brackets, I<without any spaces>:

=begin code
say 2 * <73+10i>; # OUTPUT: «146+20i␤»

multi how-is-it (<2+4i>) { say "that's my favorite number!" }
multi how-is-it (|)      { say "meh"                        }
how-is-it 2+4i;  # OUTPUT: «that's my favorite number!␤»
how-is-it 3+2i;  # OUTPUT: «meh␤»
=end code

=head1 C<Rational>

The types that do the L<Rational> role offer high-precision and
arbitrary-precision decimal numbers. Since the higher the precision the
larger the performance penalty, the L<Rational> types come in three flavours:
L<Rat>, L<MidRat>, and L<FatRat>. The L<Rat> is the most oft-used variant
that degrades into a L<Num> when it can no longer hold all of the requested
precision. The L<FatRat> is the arbitrary-precision variant that keeps growing
to provide all of the requested precision. Lastly, the L<MidRat> type is
somewhat in-between of a L<Rat> and L<FatRat>: offering arbitrary-precision
but degrading like a L<Rat>, when used in lower-precision operations.

=head2 C<Rat>

The most common of L<Rational> types. It supports rationals with denominators
as large as 64 bits (after reduction of the fraction to the lowest denominator).

The L<Rat> literals use syntax similar to L<Num> literals in many other
languages, using the dot to indicate the number is a decimal:

=begin code
say .1 + .2 == .3; # OUTPUT: «True␤»
=begin code

If you try to execute a statement similar to the above in many common
languages, you'll get C<False> as the answer, due to imprecision of
floating point math. To get the same result in Perl 6, you'd have to use
L<Num> literals instead:

=begin code
say .1e0 + .2e0 == .3e0; # OUTPUT: «False␤»
=begin code

You can also use L«C</> division operator|/routine/$SOLIDUS» with L<Int> or
L<Rat> objects to produce a L<Rat>:

=begin code
say 3/4;     # OUTPUT: «0.75␤»
say 3/4.2;   # OUTPUT: «0.714286␤»
say 1.1/4.2; # OUTPUT: «0.261905␤»
=end code

Keep in mind the above syntax is just a division expression and precedence
rules apply. It also cannot be used in places that forbit expressions, such
as literals in routine parameters.

=begin code
# Precedence of power operators is higher than division
say 3/2²; # OUTPUT: «0.75␤»
=end code

To avoid these issues, you can choose to use the L<Rational> literal syntax
instead, which involves surrounding the numerator and denominator with angle
brackets, I<without any spaces>:

=begin code
say <3/2>²; # OUTPUT: «2.25␤»

multi how-is-it (<3/2>) { say "that's my favorite number!" }
multi how-is-it (|)     { say "meh"                        }
how-is-it 3/2;  # OUTPUT: «that's my favorite number!␤»
how-is-it 1/3;  # OUTPUT: «meh␤»
=end code

Lastly, any Unicode character with property C<No> that represents a fractional
number can be used as a L<Rat> literal:

=begin code
say ½ + ⅓ + ⅝ + ⅙; # OUTPUT: «1.625␤»
=end code

=head3 Degradation to C<Num>

If a I<mathematical operation> that produces a L<Rat> answer would produce
a L<Rat> with denominator larger than 64 bits, that operation would instead
return a L<Num> object. When I<constructing> a L<Rat> (i.e. when it is not
a result of some mathematical expression), however, in similar
circumstances a L<MidRat> type is produced instead.

=head2 C<MidRat>

The L<MidRat> type is the
L<allomorph|/language/glossary#index-entry-Allomorph>
of a L<Rat> and L<FatRat> types: it's used when construction of a L<Rat> object
is attempted, but too much precision is requested. The L<MidRat> can hold
all of the given precision, just like a L<FatRat> would, but it doesn't have
the same "infectiousness" so if it's not used in high-precision operations with
other L<FatRat> objects, it'll degrade to a L<Num>, just like a L<Rat> object
would.

Attempts to I<construct> a L<Rat> with denominator larger (after reduction)
than 64 bits in size produce a L<MidRat>
object (L<MidRatStr> allomorph for L<RatStr> allomorph constructon). Such
construction occurs when a L<Rational> literal is typed in the code, the
L«C<Str.Rat>|/type/Str#method_Rat» or L«C<Str.Numeric>|/type/Str#method_Numeric» methods are
used, or a L<RatStr> allomorph is created using L<val>,
L<angle brackets|/language/quoting#index-entry-<_>_word_quote>, or other
allomorph-producing means, such as arguments to
L«C<MAIN> routine|/language/functions#sub_MAIN» or calling
L«C<RatStr.new>|/type/RatStr#method_new». Mathematical operations are B<NOT>
subject to this rule and instead degrade their result to a L<Num> instead.

=head2 C<FatRat>

The last L<Rational> type—L<FatRat>—keeps all of the precision you ask of
it, storing the numerator and denominator as two L<Int> objects. A L<FatRat>
is more infectious than a L<Rat>, so many math operations with a L<FatRat> will
produce another L<FatRat>, preserving all of the available precision. Where
a L<Rat> degrades to a L<Num>, math with a L<FatRat> keeps chugging along:

=begin code
say ((42 + Rat.new(1,2))/999999999999999999).^name;         # OUTPUT: «Rat␤»
say ((42 + Rat.new(1,2))/9999999999999999999).^name;        # OUTPUT: «Num␤»
say ((42 + FatRat.new(1,2))/999999999999999999).^name;      # OUTPUT: «FatRat␤»
say ((42 + FatRat.new(1,2))/99999999999999999999999).^name; # OUTPUT: «FatRat␤»
=end code

There's no special operator or syntax available for construction of L<FatRat>
objects. Simply use L«C<FatRat.new> method|/type/FatRat#(Rational)_method_new»,
giving numerator as first positional argument and denominator as the second.

If your program requires a significant amount of L<FatRat> creation, you could
create your own custom operator:

=begin code
sub infix:<🙼> { FatRat.new: $^a, $^b }
say (1🙼3).perl; # OUTPUT: «FatRat.new(1, 3)␤»
=end code

=head2 Printing Rationals

Keep in mind that output routines like L<say> or L<put> do not try very hard to
distinguish between how L<Numeric> types are output and may choose to display
a L<Num> as an L<Int> or a L<Rat> number. For a more definitive string to
output, use the L<perl> method:

=begin code
say 1.0;        # OUTPUT: «1␤»
say ⅓;          # OUTPUT: «0.333333␤»
say 1.0.perl;   # OUTPUT: «1.0␤»
say ⅓.perl;     # OUTPUT: «<1/3>␤»
=end code

For even more information, you may choose see the L<Rational> object in
the L<nude>, displaying its B<nu>merator and B<de>nominator:

=begin code
say ⅓;          # OUTPUT: «0.333333␤»
say 4/2;        # OUTPUT: «2␤»
say ⅓.perl;     # OUTPUT: «<1/3>␤»
say <4/2>.nude; # OUTPUT: «(2 1)␤»
=end code

=head1 Allomorphs

L<Allomorphs|/language/glossary#index-entry-Allomorph> are subclasses of two types that can
behave as either of them. For example, the allomorph L<IntStr> is the subclass of L<Int> and
L<Str> types and will be accepted by any type constraint that requires an L<Int> or L<Str> object.

Allomorphs can be created using L«angle brackets|/language/quoting#Word_quoting:_<_>», either used
standalone or as part of a hash key lookup; directly
using method C<.new>; and are also provided by some constructs such as
parameters of L«C<sub MAIN>|/language/functions#sub_MAIN» or, in the case of the L<MidRat>
allomorph, L<Rational> literals with large denominators.

=begin code
say <42>.^name;                      # OUTPUT: «IntStr␤»
say <42e0>.^name;                    # OUTPUT: «NumStr␤»
say < 42+42i>.^name;                 # OUTPUT: «ComplexStr␤»
say < 1/2>.^name;                    # OUTPUT: «RatStr␤»
say <0.5>.^name;                     # OUTPUT: «RatStr␤»
say <1/99999999999999999999>.^name;  # OUTPUT: «MidRat␤»
say < 1/99999999999999999999>.^name; # OUTPUT: «MidRatStr␤»

@*ARGS = "42";
sub MAIN($x) { say $x.^name }        # OUTPUT: «IntStr␤»

say IntStr.new(42, "42").^name;      # OUTPUT: «IntStr␤»
=end code

A couple of constructs above have a space after the opening angle bracket. That space isn't
accidental. Numerics that are often written using an operator, such as C<1/2> (L<Rat>,
division operator) and C<1+2i> (L<Complex>, addition) can be written as a literal that doesn't
involve the use of an operator: angle brackets I<without> any spaces between the brackets and the
characters inside. By adding spaces within the brackets, we tell the compiler that not only we
want a L<Rat> or L<Complex> literal, but we also want it to be an allmorph: the L<RatStr> or
L<ComplexStr>, in this case.

If the numeric literal doesn't use any operators, then writing it inside the angle brackets, even
without including any spaces within, would produce the allomorph. (Logic: if you didn't want
the allomorph, you wouldn't use the angle brackets. The same isn't true for operator-using
numbers as some constructs, such as signature literals, do not let you use operators, so you
can't just omit angle brackets for such numeric literals).

=head2 Available Allomorphs

The core language offers the following allomorphs:

=begin table

    Type       | Allomorph of         | Example
    ===========+======================+=================
    IntStr     | Int and Str          | <42>
    NumStr     | Num and Str          | <42e0>
    ComplexStr | Complex and Str      | < 1+2i>
    RatStr     | Rat and Str          | <1.5>
    MidRat     | Rat and FatRat       | <1/99999999999999999999>
    MidRatStr  | Rat, FatRat, and Str | < 1/99999999999999999999>

=end table

Note: there is no C<FatRatStr> type.

=head2 Coercion of Allomorphs

Keep in mind that allomorphs are simply subclasses of the two (or three) types they represent. Just
as a variable or parameter type-constrained to C<Foo> can accept any subclass of C<Foo>, so will
a variable or parameter type-constrained to L<Int> will accept an L<IntStr> allomorph:

=begin code
sub foo(Int $x) { say $x.^name }
foo <42>;                          # OUTPUT: «IntStr␤»
my Num $y = <42e0>;
say $y.^name;                      # OUTPUT: «NumStr␤»
=end code

This, of course, also applies to parameter L<coercers|/type/Signature#Coercion_Type>:

=begin code
sub foo(Int(Cool) $x) { say $x.^name }
foo <42>;  # OUTPUT: «IntStr␤»
=end code

The given allomorph is I<already> an object of type L<Int>, so it does not get converted to
a "plain" L<Int> in this case.

Of course, the power of allomorphs would be severely diminished if there were no way to
"collapse" them to one of their components. Thus, if you explicitly call a method with the name
of the type to coerce to, you'll get just that component. The same applies to any proxy methods,
such as calling method L«C<.Numeric>|/routine/Numeric» instead of L«C<.Int>|/routine/Int»
or using the L«C<< prefix:<~> >> operator|/routine/~» instead of
L«C<.Str>|/routine/Str» method call.

=begin code
my $al := IntStr.new: 42, "forty two";
say $al.Str;  # OUTPUT: «forty two␤»
say +$al;     # OUTPUT: «42␤»

say <1/99999999999999999999>.^name;        # OUTPUT: «MidRat␤»
say <1/99999999999999999999>.Rat.^name;    # OUTPUT: «Rat␤»
say <1/99999999999999999999>.FatRat.^name; # OUTPUT: «FatRat␤»
=end code

A handy way to coerce a whole list of allomorphs is by
L<hypering|/language/operators#Hyper_Operators> the appropraite prefix operator:

=begin code
say map *.^name,   <42 50e0 100>;  # OUTPUT: «(IntStr NumStr IntStr)␤»
say map *.^name, +«<42 50e0 100>;  # OUTPUT: «(Int Num Int)␤»
say map *.^name, ~«<42 50e0 100>;  # OUTPUT: «(Str Str Str)␤»
=end code

=head2 Object Identity

The above discussion on coercing allomorphs becomes more important when we consider object
identity. Some constructs untilize it to ascertain whether two objects are "the same". And while
to humans an allomorphic C<42> and regular C<42> might appear "the same", to those constructs,
they're entirely different objects:

=begin code
# "42" shows up twice in the result: 42 and <42> are different objects:
say unique 1, 1, 1, 42, <42>; # OUTPUT: «(1 42 42)␤»
# Use a different operator to `unique` with:
say unique :with(&[==]), 1, 1, 1, 42, <42>; # OUTPUT: «(1 42)␤»
# Or coerce the input instead (faster than using a different `unique` operator):
say unique :as(*.Int), 1, 1, 1, 42, <42>; # OUTPUT: «(1 42)␤»
say unique +«(1, 1, 1, 42, <42>);         # OUTPUT: «(1 42)␤»

# Parametarized Hash with `Any` keys does not stringify them; our key is of type `Int`:
my %h{Any} = 42 => "foo";
# But we use the allomorphic key of type `IntStr`, which is not in the Hash:
say %h<42>:exists;           # OUTPUT: «False␤»
# Must use curly braces to avoid the allomorph:
say %h{42}:exists;           # OUTPUT: «False␤»

# We are using a set operator to look up an `Int` object in a list of `IntStr` objects:
say 42 ∈ <42 100 200>; # OUTPUT: «False␤»
# Convert it to an allomorph:
say <42> ∈ <42 100 200>; # OUTPUT: «True␤»
# Or convert the items in the list to plain `Int` objects:
say 42 ∈ +«<42 100 200>; # OUTPUT: «True␤»
=end code

Be mindful of these object identity differences and coerce your allomorphs as needed.

=head1 Native Numerics

As the name suggests, native numerics offer access to native numerics—i.e. those offered directly
by your hardware. This in turn offers two features: overflow/underflow and better performance.

B<NOTE:> at the time of this writing (2018.05), certain implementations (such as Rakudo) offer
somewhat spotty details on native types, such as whether C<int64> is available and is of 64-bit
size on 32-bit machines, and how to detect when your program is running on such hardware.

=head2 Available Native Numerics

=begin table

    Native type | Base numeric     | Size
    ============+==================+===============
    int         | integer          | 64-bits
    int8        | integer          | 8-bits
    int16       | integer          | 16-bits
    int32       | integer          | 32-bits
    int64       | integer          | 64-bits

    uint        | unsigned integer | 64-bits
    uint8       | unsigned integer | 8-bits
    uint16      | unsigned integer | 16-bits
    uint32      | unsigned integer | 32-bits
    uint64      | unsigned integer | 64-bits

    num         | floating point   | 64-bits
    num32       | floating point   | 32-bits
    num64       | floating point   | 64-bits

=end table

=head2 Creating Native Numerics

To create a natively-typed variable or parameter, simply use the name of one of the available
numerics as the type constraint:

=begin code
my int32 $x = 42;
sub foo(num $y) {}
class { has int8 $.z }
=end code

At times, you may wish to coerce some value to a native type without creating any usable variables.
There are no C<.int> or similar coersion methods (method calls are latebound, so they're not
well-suited for this purpose). Instead, simply use an anonymous variable:

=begin code :preamble<my $y; my $z;>
some-native-taking-sub (my int $ = $y), (my int32 $ = $z)
=end code

=head2 Overflow/Underflow

Trying to B<assign> a value that does not fit into a particular native type, produces an exception:

=begin code
my int $x = 2¹⁰⁰;
# OUTPUT:
# Cannot unbox 101 bit wide bigint into native integer
#  in block <unit> at -e line 1
=end code

However, modifying an already-existing value in such a way that it becomes too big/small, produces
overflow/underflow behaviour:

=begin code
my int $x = 2⁶³-1;
say $x;             # OUTPUT: «9223372036854775807␤»
say ++$x;           # OUTPUT: «-9223372036854775808␤»

my uint8 $x;
say $x;             # OUTPUT: «0␤»
say $x -= 100;      # OUTPUT: «156␤»
=end code

Creating objects that utilize native types does not involve direct assignment by the programmer
and so these contructs offer overflow/underflow behaviour instead of throwing exceptions. The
same reasoning applies when a routine with a smaller native type is called with a larger value.

=begin code
say Buf.new(1000, 2000, 3000).List; # OUTPUT: «(232 208 184)␤»
say my uint8 @a = 1000, 2000, 3000; # OUTPUT: «232 208 184␤»

sub foo(int8 $x) { say $x }
foo my int $x = 10000;              # OUTPUT: «16␤»
=end code

=head2 Auto-boxing and Multi Dispatch

While they can be referred to as "native I<types>", native numerics are not actually classes
that have any sort of methods available. However, you I<can> call any of the methods available
on non-native versions of these numerics. What's going on?

=begin code
my int8 $x = -42;
say $x.abs; # OUTPUT: «42␤»
=end code

This behaviour is known as "auto-boxing". The compiler automatically "boxes" the native type
into a full-featured higher-level type with all the methods. In other words, the C<int8> above
was automatically converted to an L<Int> and it's the L<Int> class that then provided the L<abs>
method that was called.

This detail becomes significant in two situations. First, if a routine is an C<only>—i.e. it is
not a L«C<multi>|/language/functions#Multi-dispatch»—that takes a non-native type but a native
one was given during the call, it will be autoboxed. However, no auto-boxing will occur
with a L«C<multi>|/language/functions#Multi-dispatch» candidate—you must provide a native candidate
for it to be callable.

=begin code
sub one-over (Int $x) { 1/$x }
one-over my int $ = 42; # OK; auto-boxed

multi one-over-multi (Int $x) { 1/$x }
one-over-multi my int $ = 42; # BAD; no native candidate

multi one-over-multi2 (Int $x) { 1/$x }
multi one-over-multi2 (int $x) { 1/$x }
one-over-multi2 my int $ = 42; # OK; we have a native candidate
=end code

The size of the native type does not play a role in dispatch and an C<int8> is considered to be
the same as C<int16> or C<int>:

=begin code
multi foo(int   $x) { say "int" }
multi foo(int32 $x) { say "int32" }
foo my int $x = 42;
# OUTPUT:
# Ambiguous call to 'foo(Int)'; these signatures all match:
# :(int $x)
# :(int32 $x)
=end code

A small exception to the multi dispatch rule involves constant-foldable routines that are called
with a native type and another argument that's a numeric literal small enough to fit to a
native type. This feature exists to support native (faster) versions of certain operators:

=begin code
multi infix:<foo> (Int, Int) is pure { "full" }
multi infix:<foo> (int, int) is pure { "native" }
say 42 foo 42;            # OUTPUT: «full␤»
say 42 foo my int $ = 42; # OUTPUT: «native␤»
=end code

=head1 Numeric Infectiousness

Numeric "infectiousness" dictates the resultant type when two numerics of different types are
involved in some mathematical operations. A type is said to be more infectious than the other type
if the result is of that type rather than the type of the other operand. For example, L<Num>
type is more infectious than an L<Int>, thus we can expect C<42e0 + 42> to produce a L<Num> as the
result.

The infectiousness is as follow, with the most infectious type listed first:

=begin table

    Type    | Comments
    ========+===========
    Complex |
    Num     |
    FatRat  |
    MidRat  | Special infectiousness. See prose that follows.
    Rat     |
    Int     |

=end table

The L<MidRat> type is a special type that offers greater precision, like a L<FatRat> type, yet
has the same infectiousness as a L<Rat> type. In other words, operations involving a L<MidRat>
type and a L<MidRat>, L<Rat>, or L<Int> type would result in a L<Rat> result, B<not> L<MidRat>
result (or a L<Num> result if after reduction the denominator ended up over 64-bits, too large for
a L<Rat>). Otherwise, we're dealing with a type more infectious than a L<MidRat> and the result will
be of that type.

Some examples of what we discussed:

=begin code
say (2 + 2e0).^name; # Int + Num => OUTPUT: «Num␤»
say (½ + ½).^name; # Rat + Rat => OUTPUT: «Rat␤»
say (FatRat.new(1,2) + ½).^name; # FatRat + Rat => OUTPUT: «FatRat␤»
say (FatRat.new(1,2) + <1/99999999999999999999>).^name; # FatRat + MidRat => OUTPUT: «FatRat␤»

say (99999999999999999999 * <1/99999999999999999999>).^name;
# Int * MidRat (after reduction, denominator fits into a Rat) => OUTPUT: «Rat␤»
say (1 + <1/99999999999999999999>).^name;
# Int * MidRat (after reduction, denominator too big to fit into a Rat) => OUTPUT: «Num␤»
=end code

The allomorphs have the same infectiousness as their numeric component. Native types get autoboxed
and have the same infectiousness as their boxed variant.

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
