=begin pod :tag<perl6>

=TITLE Data structures

=SUBTITLE How Perl 6 deals with data structures and what we can expect from them.

=head1 Scalar structures

Some classes do not have any I<internal> structure, and to access parts of them
specific methods have to be used. Numbers, strings, and some other monolithic
classes are included in that class. They use the C<$> sigil, although complex
data structures can also use it.

    my $just-a-number = 7;
    my $just-a-string = "8";

There is a L<Scalar> class, which is used internally to assign a default value
to variables declared with the C<$> sigil.

    my $just-a-number = 333;
    say $just-a-number.VAR.^name; # OUTPUT: «Scalar␤»

Any complex data structure can be I<scalarized> by using the L<item
contextualizer C<$>|/type/Any#index-entry-%24_(item_contextualizer)>:

    (1,2,3, $(4,5))[3].VAR.^name.say; # OUTPUT: «Scalar␤»

However, this means that it will be treated as such in the context they are. You
can still access its internal structure.

    (1,2,3, $(4,5))[3][0].say; # OUTPUT: «4␤»

An interesting side effect, or maybe intended feature, is that scalarization
conserves identity of complex structures.

    for ^2 {
         my @list =(1,1);
         say @list.WHICH;
    } # OUTPUT: «Array|93947995146096␤Array|93947995700032␤»

Every time C<(1,1)> is assigned, the variable created is going to be different
in the sense that C<===> will say it is; as it is shown, different values of the
internal pointer representation are printed. However

    for ^2 {
      my $list =(1,1);
      say $list.WHICH
    }   # OUTPUT: «List|94674814008432␤List|94674814008432␤»

In this case, C<$list> is using the Scalar sigil and thus will be an C<Scalar>. Any scalar will the same value will be exactly the same, as shown when printing the pointers.

=head1 Complex data structures

Complex data structures fall in two different broad categories L<Positional|/type/Positional>, or list-like and L<Associative|/type/Associative>, or key-value pair like, according to how you access its first-level elements. In general, complex data structures, including objects, will be a combination of both, with object properties assimilated to key-value pairs.



=head1 Functional structures

TBD

=head1 Infinite structures and laziness

TBD

=head1 Introspection

TBD

=head1 Defining and constraining data structures

TBD

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
